#+TITLE: Design Doc
* Parser
  Precedence: '.' and '[]' subscript.
  '.' stronger
* Semantics
** Types
   
#+BEGIN_SRC haskell -n
data Type = TInt
          | TString
          | TRecord [(AST.Id, Type)]
          | TArray [Type]
          | TNil
          | TUnit
          | TName [(AST.Id, Type)]
#+END_SRC

** Symbol Tables
*** Symbol
    newtype Symbol = Symbol String
*** Variable/Function Environment
Map: Symbol -> Type
*** Type Environment
Map: Symbol -> Type
** Testcases
   - [ ] test5: Valid recursive record
   - [ ] test16: mutually recursive types that do not pass through record
   - [X] test23: hmmm...
   - [X] test24: hmmm...
   - [X] test25: hmmm...
   - [X] test31: type constaint and init value defer
   - [X] test32: type constaint and array init expr defer
   - [ ] test32: Error not being evaluated. Therefore error not thrown.
   - [X] test33: unknown rec type
   - [ ] test33: Error not being evaluated. Therefore error not thrown.
   - [X] test37: redeclaration
   - [X] test38: redeclaring types are illegal
   - [X] test39: redeclaring functions are illegal
     Also sym tables from arg list missing in function body
   - [ ] test42: Type equality
   - [ ] test44: Nil and record compatibility
   - [ ] test45: Nil and record compatibility
   - [ ] test46: Nil and record compatibility
   - [ ] test47: Mutual recursion
   - [ ] test48: Mutual recursion
   - [ ] queen: Type equality
   - [ ] merge: Type equality

** Error Messages
   Needs work.
   Possible Idea:
   typeCheck :: * -> Either ErrorBuffer Type 
   Every call to typeCheck has to check if it encountered ErrorBuffer.
   Whenever types are invalid, build up buffer.
